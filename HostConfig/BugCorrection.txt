CpcDos Compileur://src\include/llvm/Support/ScaledNumber.h:783:13: error: ambiguous overload for 'operator<' (operand types are 'const llvm::ScaledNumber<long long unsigned int>' and 'int')  if (*this < 1) change 2    if (*this < (IntT)1)      BitcodeWriter.cpp:3015  unsigned  Position = 0;   2  uint32_t Position = 0;  Remove MIRParser/ YalmRuntimeDyld.cpp:367      unsigned Alignment = (unsigned)Alignment64 & 0xffffffffL;	  2	  uint32_t Alignment = (uint32_t)Alignment64 & 0xffffffffL;	  	  	 Remove COFFYAML and following dependancy////////////////////////////////////////////////////////////////////////////////	 	 	 template <> struct ScalarTraits<UnsignedValue> {	   static void output(const UnsignedValue &Value, void *Ctx, raw_ostream &OS) {    return ScalarTraits<unsigned>::output(Value.Value, Ctx, OS);	2/// A wrapper around unsigned which contains a source range that's being set/// during parsing.struct UnsignedValue {  uint32_t Value;  SMRange SourceRange;  UnsignedValue() : Value(0) {}  UnsignedValue(uint32_t Value) : Value(Value) {}  bool operator==(const UnsignedValue &Other) const {    return Value == Other.Value;  }};template <> struct ScalarTraits<UnsignedValue> {  static void output(const UnsignedValue &Value, void *Ctx, raw_ostream &OS) {    return ScalarTraits<uint32_t>::output(Value.Value, Ctx, OS);  }  static StringRef input(StringRef Scalar, void *Ctx, UnsignedValue &Value) {    if (const auto *Node =            reinterpret_cast<yaml::Input *>(Ctx)->getCurrentNode())      Value.SourceRange = Node->getSourceRange();    return ScalarTraits<uint32_t>::input(Scalar, Ctx, Value.Value);  }  static bool mustQuote(StringRef Scalar) {    return ScalarTraits<uint32_t>::mustQuote(Scalar);  }};//////////////////////////////////////////////////////////////////////////////Missing sizofYamlTraitadd {}; 2D:\_MyLLVM_3_8_0\src\include\llvm\Support\YAMLTraits.h \187struct MissingTrait{};///////////////////////////////////////src\lib\Support\ScaledNumber.cpp:168:69: error: no matching function for call to 'min(const int32_t&, int)'change 2 int32  int NewE = std::min(ScaledNumbers::MaxScale, ((int32_t)(E + 63 - LeadingZeros)) );   src\lib\Tf\Ins\AddressSanitizer.cpp:1086:66: error: no matching function for call to 'max(unsigned int, uint32_t)'change 2      IntegerType::get(*C, std::max((uint32_t)(8U), (uint32_t)(TypeSize >> Mapping.Scale) ));           //////////////////////  -DD__STDC_LIMIT_MACROS -DD__STDC_CONSTANT_MACROS  C:\LLVM\_MYLLV~1>gpp @a -c src\lib\Support\regcomp.c -o r\src\lib\Support\regcomp.o  change 2 size_t if ((size_t)size > SIZE_MAX / sizeof(sop)) {